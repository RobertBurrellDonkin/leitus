#!/usr/bin/env python
#
# Copyright (c) Robert Burrell Donkin 2011
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
#
# Leitus is a suite of higher level functions for cryptographic drives.
#
# Robert Burrell Donkin, 2011
#

import subprocess
import os.path
import shutil
import os

class ResourceError(Exception):
    """
    Raised when a resource causes an operation to failure.
    
    Attributes:
       resource -- the resource in question
       message -- template formatted during display
    """
    def __init__(self, resource, message):
        self.resource = resource
        self.message = message
        
    def __str__(self):
        return self.message.format(self.resource)

class NotFoundError(ResourceError):
    """
    Raised when a resource (such as a drive, device or file)
    required by an operation cannot be located.
    
    Attributes:
       resource -- which cannot be located
       message -- template formatted during display
    """
    def __init__(self, resource):
        ResourceError.__init__(self, resource, "{0} not found.")

class AlreadyInUseError(ResourceError):
    """
    Raised an operations conflicts with an existing use of
    a entity (such as a drive, device or file).
    
    Attributes:
       entity -- currently in use
       message -- template formatted during display
    """
    def __init__(self, entity):
        ResourceError.__init__(self, entity, "{0} is already in use.")
    
class SubprocessLoopDevice():
    """
    Low level API for loop devices
    """
    
    def status(self, file):
        """
        Status of every loop device mapped to the given file.
        """
        status = subprocess.check_output(["losetup", "-j", file])
        if (len(status)):
            return status
        return None
    
    def firstUnusedDevice(self):
        """
        The name of the first unused device.
        """
        return subprocess.check_output(["losetup", "-f"]).strip()
    
    def open(self, file, device):
        """
        Mounts the given file as a loopback on the first available
        device.
        
        Returns - the device name
        """
        subprocess.check_call(["losetup", device, file])
    
    def create(self, file, count):
        """
        Fills with random data
        
        count in megabytes
        """
        subprocess.check_call(
            ['dd', 'if=/dev/urandom', 'of=' + file, 'count={0}'.format(count),
             'conv=fsync', 'iflag=nonblock', 'bs=1M'])



class LoopDevice():
    """
    High level API for loop devices
    """
    def __init__(self, file):
        self.file = file
        self.api = SubprocessLoopDevice()
    
    def __repr__(self):
        return "Loop device (based on '{0}')".format(self.file)
    
    def open(self):
        if (not os.path.exists(self.file)):
            raise NotFoundError, self.file
        if (self.isInUse()):
            raise AlreadyInUseError, self
        self.api.open(self.file, self.firstUnusedDevice())
        return self
    
    def isInUse(self):
        return (os.path.exists(self.file) and not(self.status() == None))
    
    def status(self):
        return self.api.status(self.file)
    
    def firstUnusedDevice(self):
        return self.api.firstUnusedDevice()
        
    def create(self, size):
        """
        Creates a new device of the given size
        filled with random data.
        
        size (in megabytes)
        """
        if (os.path.exists(self.file)):
            raise AlreadyInUseError, self.file
        self.api.create(self.file, size)
        return self
    
    def deviceName(self):
        status = self.status()
        if (status == None):
            raise NotFoundError, self
        return status.split(":", 1)[0]
        
    
class CryptSetup():
    
    def map(self, name, device):
        args = ['cryptsetup',
                '-d', '/dev/urandom',
                'create',
                name, device]
        subprocess.check_call(args)
    
class CryptDeviceWithRandomKey():
    
    def on(self, source):
        return DeviceMapping(source.deviceName(), CryptSetup())
    
    
class DeviceMapping():
    def __init__(self, device, api):
        self.device = device
        self.api = api
    
    def nameAfterMapping(self, name):
        return '/dev/mapper/{0}'.format(name)
    
    def mapTo(self, name):
        self.api.map(name, self.device)
        return FileSystemOnDeviceMapping(self.nameAfterMapping(name))

class Ext3():
    
    def format(self, device):
        subprocess.check_call(['mke2fs', '-j', '-m', '1', '-O',
                               'dir_index,filetype',
                               device])        
    
class SubprocessMount():
    def mount(self, device, onPath):
        subprocess.check_call(['mount', device, onPath])

class FileSystemOnDeviceMapping():
    
    def __init__(self, onDevice):
        self.onDevice = onDevice;
        self.api = SubprocessMount()

    def makeFormat(self, api):
        api.format(self.onDevice)
    
    def mountOn(self, path):
        self.api.mount(self.onDevice, path)
        return MountedFileSystem(path)

class Copy():
    """
    Copy operations.
    """
    def __init__(self, source):
        self.source = source
        
    def into(self, target):
        """
        Copies (recursively) all files in source into the
        given target directory. (As far as possible) meta-data
        is preserved.
        """
        if not (os.path.exists(self.source)):
            raise NotFoundError, source
        if not (os.path.exists(target)):
            raise NotFoundError, target
        for name in os.listdir(self.source):
            path = os.path.join(self.source, name)
            if os.path.isdir(path):
                shutil.copytree(path, os.path.join(target, name))
            else:
                shutil.copy2(path, target)
                

class MountedFileSystem():
    def __init__(self, mountPoint):
        self.mountPoint = mountPoint
        self.profileRoot = "profiles"
    
    def merge(self, profiles):
        if not (os.path.exists(self.mountPoint)):
            raise NotFoundError, self
        for profile in profiles:
            Copy(os.path.join(self.profileRoot, profile)).into(self.mountPoint)
    
    def __repr__(self):
        return "File system at {0}".format(self.mountPoint)
    

profiles = ['home']
name = "neo"
filename = name + ".crypt"
sizeInMegabytes = 500
target = '/mnt/buck'

# LoopDevice(filename).create(sizeInMegabytes).open().deviceName()

#CryptDeviceWithRandomKey().on(LoopDevice(filename)).mapTo(name).makeFormat(Ext3())

#FileSystemOnDeviceMapping("neo").makeFormat(Ext3())

#FileSystemOnDeviceMapping("/dev/mapper/neo").mountOn(target)

MountedFileSystem(target).merge(profiles)

##############################################################################
#
# Aborginal Sources
#
##############################################################################

##
## Creates an encrypted loopback drive.
##
##
##
#
#MAP_NAME=name-robertburrelldonkin-temp
#
#
#source name.robertburrelldonkin.linux.crypt_functions
#
#if [ -z $1 ]
#then
# echo "Usage <filename> <initial size in M>"
# exit 1
#fi
#
#if [ -e $1 ]
#then
# echo "File already exists"
# exit 1
#fi
#
#fillWithRandom $1 $2
#mountLoopDevice $1
#setUpLUKS $LoopDevice 
#openLUKS $LoopDevice $MAP_NAME
#makeFileSystem $MAP_NAME
#tidyUp $LoopDevice $MAP_NAME
#
#exit 0


## Closes an encrypted loopback drive.
##
##
##
#
#source name.robertburrelldonkin.linux.crypt_functions
#
#if [ -z $3 ]
#then
# echo "Usage <loop file> <map name> <mount point>"
# exit 1
#fi
#
#echo "Unmounting $3..."
#umount $3
#sleep 1
#tidyUp $1 $2
#exit 0



##
## Aim: Setup LUKS on the device.
##
#setUpLUKS() {
# if [ -z $1 ]
# then
#  echo "Usage: setUpsLUKS <filename>"
#  exit 1
# fi
#
# echo "Setting up LUKS on $1"
# cryptsetup luksFormat -c aes-cbc-essiv:sha256 $1
# if [ $? -eq 0 ]
# then
#  echo "Setup LUKS on $1"
# else
#  echo "LUKS setup on $1 failed."
#  exit 1
# fi
#}
#
#
##
## Aim: Map to an available name
##
#openLUKS() {
# if [ -z $2 ]
# then
#  echo "Usage: openLUKS <device> <map name>"
#  exit 1
# fi
#
# for name in `dmsetup ls | cut -f1`
# do
#  if [ "$name" == "$2" ] 
#  then
#   echo "/dev/mapper/$2 is already mapped."
#   exit 1
#  fi
# done
# echo "Opening $1 onto $2"
# cryptsetup luksOpen $1 $2
# if [ $? -eq 0 ]
# then
#  echo "Opened $1 on $2"
# else
#  echo "Failed to open $1 on $1."
#  exit 1
# fi
#}
#
#
##
## Tidy up
##
#tidyUp() {
# if [ -z $2 ]
# then
#  echo "Usage: tidyUp <loop device> <map name>"
#  exit 1
# fi
#
# echo "Closing and unmounting $1"
# sleep 2s
# cryptsetup luksClose $2
# sleep 1s
# losetup -d $1
# echo "Done."
#}
